extern crate sdl2;

use sdl2::event::Event;
use sdl2::keyboard::Keycode;
use sdl2::pixels::Color;
use sdl2::rect::Point;
use std::time::Duration;
use rand::Rng;
use ndarray::Array3;


const WIDTH: usize = 400;
const HEIGHT: usize = 400;

fn main() {
    let sdl_context = sdl2::init().unwrap();
    let video_subsystem = sdl_context.video().unwrap();

    let window = video_subsystem.window("rust-sdl2 demo", WIDTH as u32, HEIGHT as u32)
        .position_centered()
        .build()
        .unwrap();

    let mut canvas = window.into_canvas().build().unwrap();

    let mut a: Array3<f32> = Array3::zeros((WIDTH, HEIGHT, 2));
    let mut b: Array3<f32> = Array3::zeros((WIDTH, HEIGHT, 2));
    let mut c: Array3<f32> = Array3::zeros((WIDTH, HEIGHT, 2));

    let mut rnd = rand::thread_rng();

    for i in 0..WIDTH as usize {
        for j in 0..HEIGHT as usize {
            a[[i, j, 0]] = rnd.gen::<f32>();
            b[[i, j, 0]] = rnd.gen::<f32>();
            c[[i, j, 0]] = rnd.gen::<f32>();
        }
    }

    canvas.set_draw_color(Color::RGB(0, 0, 0));
    canvas.clear();
    canvas.present();
    let mut event_pump = sdl_context.event_pump().unwrap();
    'running: loop {
        for event in event_pump.poll_iter() {
            match event {
                Event::Quit {..} |
                Event::KeyDown { keycode: Some(Keycode::Escape), .. } => {
                    break 'running
                },
                _ => {}
            }
        }

        for i in 1..WIDTH {
            for j in 1..HEIGHT {
                let (mut c_a, mut c_b, mut c_c) = (0.0, 0.0, 0.0);
                for x in i-1..=i+1 {
                    for y in j-1..=j+1 {
                        let ii = (x + WIDTH) % WIDTH;
                        let jj = (y + HEIGHT) % HEIGHT;
                        println!("{}", ii);
                        c_a += curr_a[ii];
                        c_b += curr_b[ii];
                        c_c += curr_c[ii];
                    }
                }
                c_a /= 9.0;
                c_b /= 9.0;
                c_c /= 9.0;
                next_a[i * HEIGHT + j] = constrain(c_a + c_a * (c_b - c_c), 0.0, 1.0);
                next_b[i * HEIGHT + j] = constrain(c_b + c_b * (c_c - c_a), 0.0, 1.0);
                next_c[i * HEIGHT + j] = constrain(c_c + c_c * (c_a - c_b), 0.0, 1.0);
                println!("{}", next_a[i * HEIGHT + j]);
                canvas.set_draw_color(Color::RGB((0.5 * 255.0) as u8, (0.7 * 255.0) as u8, (next_a[i * HEIGHT + j] * 255.0) as u8));
                println!("{}, {}, {}, {}, {}", i, j, (0.5 * 255.0) as u8, (0.7 * 255.0) as u8, (next_a[i * HEIGHT + j] * 255.0) as u8);
                canvas.draw_point(Point::new(i as i32, j as i32)).expect("WHAT");
                curr_a = next_a.clone();
                curr_b = next_b.clone();
                curr_c = next_c.clone();

            }
        }

        canvas.present();
        ::std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60));
    }
}

fn constrain(val: f32, min_val: f32, max_val: f32) -> f32 {
    f32::min(max_val, f32::max(val, min_val))
}
